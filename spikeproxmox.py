from proxmoxer import ProxmoxAPI
import paramiko
import os
import sqlite3
import time

# --- PROXMOX CONFIG ---
PVE_HOST = "10.0.0.5" # Your Proxmox IP
PVE_USER = "root@pam"
PVE_TOKEN_NAME = "mc_automation"
PVE_TOKEN_VALUE = os.environ.get('PVE_TOKEN_VALUE') 
NODE_NAME = "pve" # Your node name

# Connect to the API
proxmox = ProxmoxAPI(
    PVE_HOST,
    user=PVE_USER,
    token_name=PVE_TOKEN_NAME,
    token_value=PVE_TOKEN_VALUE,
    verify_ssl=False # Set to True if you have a valid SSL cert
)

DB_FILE = "database.db"

def get_db_connection():
    """Helper to connect to the database and return rows as dictionaries."""
    conn = sqlite3.connect(DB_FILE)
    conn.row_factory = sqlite3.Row  # This lets us access columns by name
    return conn

def update_request_status(req_id, new_status):
        with get_db_connection() as conn:
            conn.execute('''
                UPDATE requests 
                SET status = ? 
                WHERE id = ?
            ''', (new_status, req_id))
        
        conn.commit()

def provision_new_server(vmid, template_id, server_data):
    try:
        # 1. Mark as 'Provisioning' in your DB
        req_id = vmid
        update_request_status(req_id, "Provisioning")
        try:
            node = proxmox.nodes("pve")
            mc_name = server_data.get('mc_name', '')
            mode = server_data.get('gamemode', 'survival').lower()
            diff = server_data.get('difficulty', 'easy').lower()
            whitelist_active = server_data.get('whitelist_enabled', 0)
            owner_name = server_data.get('owner_name', '')
            uuid = server_data.get('uuid', '')
            seed = str(server_data.get('seed', '0'))
            metadata_str = f"SEED={seed}\nDIFFICULTY={diff}\nMODE={mode}\nWHITELIST_ACTIVE={whitelist_active}\nOWNER_NAME={owner_name}\nUUID={uuid}"
            # Construct the "Data Hostname"
            # Example: mc-1-1234567-creative-hard
            encoded_hostname = f"mc-{vmid}"

            print(f"Cloning with encoded hostname: {encoded_hostname}")
            
            node.lxc(template_id).clone.post(
                newid=vmid, 
                hostname=encoded_hostname, 
                full=1
            )


            # 2. Wait until the container is unlocked
            # If we try to inject variables while it's cloning, it will error out.
            timeout = 60
            start = time.time()
            while time.time() - start < timeout:
                status = node.lxc(vmid).config.get()
                if 'lock' not in status:
                    break
                time.sleep(2)



            # 4. Fire it up

            node.lxc(vmid).status.start.post()
            time.sleep(10)  # Give it a moment to start

            host = "10.0.0.5" # Your Proxmox Host IP
            user = "root"
            password = os.environ.get('SSH_PASS')

            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
            try:
                ssh.connect(host, username=user, password=password)
                
                # Create a temp file on the Proxmox Host
                cmd_create = f"echo '{metadata_str}' > /tmp/metadata_{vmid}.txt"
                ssh.exec_command(cmd_create)
                
                # Use 'pct push' (The host tool that ignores LXC permissions)
                # This force-injects the file into the container's /root/ folder
                cmd_push = f"pct push {vmid} /tmp/metadata_{vmid}.txt /root/metadata.txt"
                ssh.exec_command(cmd_push)
                
                print(f"Successfully pushed metadata.txt to LXC {vmid}")
            finally:
                ssh.close()

        except Exception as e:
            print(f"Proxmox Error: {e}")
            return False

        time.sleep(10)  # Wait a bit before injecting config
        update_request_status(req_id, "APPROVED")
        print(f"Background Task: Request {req_id} finished successfully.")

    except Exception as e:
        update_request_status(req_id, "Failed")
        print(f"Background Task Error: {e}")



def inject_server_config(vmid, server_data, assigned_port):
    #Generates and pushes the server.properties file to the LXC.
    
    # Define the Minecraft configuration string
    # We use .strip() to remove any accidental leading/trailing whitespace
    config_content = f"""
# Minecraft Server Properties
# Dynamically generated by Python Automation
server-port={assigned_port}
gamemode={server_data['gamemode']}
difficulty={server_data['difficulty']}
level-seed={server_data['seed']}
pvp=true
enable-command-block=true
online-mode=false
allow-flight=true
motd=Welcome to {server_data['servername']}!
    """.strip()

    try:
        # We upload the string directly as a file to the container
        # Note: Ensure the path matches where your server.jar lives in the template
        proxmox.nodes(NODE_NAME).lxc(vmid).upload.post(
            content=config_content,
            filename="server.properties",
            path="/home/minecraft/"
        )
        print(f"Successfully injected config into VM {vmid} on port {assigned_port}")
        return True
    except Exception as e:
        print(f"Failed to inject config: {e}")
        return False




def delete_mc_container(vmid):
    """Stops and removes the container safely."""
    try:
        node = proxmox.nodes(NODE_NAME)
        status = node.lxc(vmid).status.current.get()['status']

        # 1. Stop the container if it's running
        if status == 'running':
            print(f"Container {vmid} is running. Stopping it now...")
            node.lxc(vmid).status.stop.post()
            
            # Wait for it to stop (check every 1 second, up to 10 times)
            for _ in range(10):
                time.sleep(1)
                current_status = node.lxc(vmid).status.current.get()['status']
                if current_status == 'stopped':
                    break
            else:
                print(f"Error: Container {vmid} took too long to stop.")
                return False

        # 2. Now that it's stopped, delete it
        node.lxc(vmid).delete()
        print(f"Container {vmid} has been deleted.")
        return True

    except Exception as e:
        print(f"Delete Error: {e}")
        return False

